//parser object that parses a list of tokens generated by lexer

import java.text.Normalizer.Form;
import java.util.*;

import Token.tokenType;

public class Parser 
{
    //declarations
    ArrayList<Token> m_Tokens;
    ProgramNode v_RootOfAST;

    //contructor for a parser object
    public Parser(ArrayList<Token> p_Tokens)
    {
        m_Tokens = p_Tokens;
        v_RootOfAST = new ProgramNode();
    }
    
    //priamry parsing method
    public ProgramNode parse() throws SyntaxErrorException 
    {
        FunctionNode v_FuntionNodesTemp = null;

        while (m_Tokens.size() > 0) 
        {
            v_FuntionNodesTemp = function(); //create start of tree

            if (v_FuntionNodesTemp == null) {
                throw new SyntaxErrorException();
            } // return null from fucnt

            v_RootOfAST.addFunctionNode(v_FuntionNodesTemp); //add to hashmap
        }
        //return
        return v_RootOfAST;
    }

    //creates a node repreentation of a bool expression after parsing it
    public Node boolCompare() throws SyntaxErrorException
    {
        Node leftSide = expression();
        Token tempToken = null;
        BooleanCompareNode.boolOperation operation = null;

        if((tempToken = matchAndRemove(Token.tokenType.EQUALS)) != null) 
        {
            operation = BooleanCompareNode.boolOperation.EQUAL;
        }
        else if((tempToken = matchAndRemove(Token.tokenType.NOTEQUAL)) != null) 
        {
            operation = BooleanCompareNode.boolOperation.NOTEQUAL;
        }
        else if((tempToken = matchAndRemove(Token.tokenType.LESSEQUALS)) != null) 
        {
            operation = BooleanCompareNode.boolOperation.LESSTHANEQUAL;
        }
        else if((tempToken = matchAndRemove(Token.tokenType.LESSTHEN)) != null) 
        {
            operation = BooleanCompareNode.boolOperation.LESSTHAN;
        }
        else if((tempToken = matchAndRemove(Token.tokenType.GREATEREQUALS)) != null) 
        {
            operation = BooleanCompareNode.boolOperation.GREATERTHANEQUAL;
        }
        else if((tempToken = matchAndRemove(Token.tokenType.GREATERTHAN)) != null) 
        {
            operation = BooleanCompareNode.boolOperation.GREATERTHAN;
        }
        else
        {
            if(((MathOpNode)leftSide).m_MathOpType == null)
            {
                leftSide = ((MathOpNode)leftSide).m_LeftNode;
            }
            return leftSide;
        }
        Node rightSide = expression();
        return new BooleanCompareNode(leftSide, rightSide, operation);
    }

    //creates and varifies fucntion nodes
    public FunctionNode function() throws SyntaxErrorException {
        Token v_name;
        VariableNode[] v_Params = null;
        Node[] v_Conts = null;
        VariableNode[] v_Vars = null;
        ArrayList<StatementNode> v_Statements = new ArrayList<>();
    
        if (matchAndRemove(Token.tokenType.DEFINE) != null) 
        {
            if ((v_name = matchAndRemove(Token.tokenType.IDENTIFIER)) != null) 
            {
                if (matchAndRemove(Token.tokenType.STARTPARAMS) != null) 
                {
                    v_Params = parameterDeclarations();
    
                    if (matchAndRemove(Token.tokenType.ENDPARAMS) != null) 
                    {
                        expectEndsOfLine();
                        if (matchAndRemove(Token.tokenType.CONSTANTS) != null) 
                        {
                            v_Conts = constantParse(0, null);
                            expectEndsOfLine();
                        }
                        if (matchAndRemove(Token.tokenType.VARIABLES) != null) 
                        {
                            v_Vars = variableParse();
                            expectEndsOfLine();
                        }                    
                        v_Statements = statements();                       
                        return new FunctionNode(v_name.getTokenValue(), v_Params, v_Conts, v_Vars, v_Statements);
                    } 
                    else 
                    {
                        throw new SyntaxErrorException(m_Tokens.toString());
                    }
                } 
                else 
                {
                    throw new SyntaxErrorException(m_Tokens.toString());
                }
            } 
            else 
            {
                throw new SyntaxErrorException(m_Tokens.toString());
            }
        } 
        else 
        {
            throw new SyntaxErrorException(m_Tokens.toString());
        }
    }

    //parses statments
    public ArrayList<StatementNode> statements() throws SyntaxErrorException {
        ArrayList<StatementNode> statementNodes = new ArrayList<StatementNode>();
        
        if(matchAndRemove(Token.tokenType.INDENT) != null)
        {
            StatementNode statementNode;
            while((statementNode = statement()) != null)
            {
                statementNodes.add(statementNode);
                if(peek(0).getTokenType() == Token.tokenType.DEDENT)
                    break;
            }
        }
        else
        {
            throw new SyntaxErrorException("Invalid statments, expected Indent" + m_Tokens);
        }
        
        if(matchAndRemove(Token.tokenType.DEDENT) != null)
        {
            return statementNodes;
        }
        else
        {
            throw new SyntaxErrorException("Invalid statments, expected Dedent" + m_Tokens);
        }
    }

    //just assigment for right now
    public StatementNode statement() throws SyntaxErrorException 
    {
        Node returnNode = null;
        if(matchAndRemove(Token.tokenType.IF) != null) //if
        {
            returnNode = parseIf();
            return (StatementNode)returnNode;
        }
        else if(matchAndRemove(Token.tokenType.WHILE) != null) //while
        {
            returnNode = parseWhile();
            return (StatementNode)returnNode;
        }
        else if(matchAndRemove(Token.tokenType.FOR) != null) //for
        {
            returnNode = parseFor();
            return (StatementNode)returnNode;
        }
        else if(peek(0).getTokenType() == Token.tokenType.IDENTIFIER) //identifier
        {
            int index = 0, isAssign = 0;
            while(peek(index).getTokenType() != Token.tokenType.ENDOFLINE)
            {
                if(peek(index).getTokenType() == Token.tokenType.ASSIGMENT)
                    isAssign = 1;  
                index++;
            }
            if(isAssign == 1) // assigment
            {
                returnNode = assignment();
                expectEndsOfLine(); //eat EOL
                return (StatementNode)returnNode;
            }
            else  //functioncall
            {
                returnNode = parseFunctionCalls();
                return (StatementNode)returnNode;
            }
        }
        else
        {
            returnNode = null;
            return (StatementNode)returnNode;
        }

        //expectEndsOfLine(); //eat EOL
        //return (StatementNode)returnNode;
    }

    //parses constants
    public Node[] constantParse(int v_level, Node[]p_ReturnConts) throws SyntaxErrorException
    {
        Node[] v_ReturnConts; 
        //checks our level and array contents becuase we allow ourselves to be called recursively to handle multiple lines of constant delcares
        if(p_ReturnConts == null)
        {
            v_ReturnConts = new Node[1];
        }
        else
        {
            v_ReturnConts = new Node[p_ReturnConts.length + 1];
            for(int i = 0; i < p_ReturnConts.length; i++)
            {
                v_ReturnConts[i] = p_ReturnConts[i];
            } 
        }
        
        Token v_Name, v_Type;

        if((v_Name = matchAndRemove(Token.tokenType.IDENTIFIER)) != null)
        {
            if(matchAndRemove(Token.tokenType.EQUALS) != null)
            {
                if((v_Type = matchAndRemove(Token.tokenType.MINUS)) != null)
                {
                    if((v_Type = matchAndRemove(Token.tokenType.REAL)) != null)
                    {
                        v_ReturnConts[v_level] = new VariableNode(v_Name.getTokenValue(), v_Type.getTokenType().toString().toLowerCase(), false, (new RealNode(0-Float.parseFloat(v_Type.getTokenValue()))));
                    }
                    else if((v_Type = matchAndRemove(Token.tokenType.INTEGER)) != null)
                    {
                        v_ReturnConts[v_level] = new VariableNode(v_Name.getTokenValue(), v_Type.getTokenType().toString().toLowerCase(), false, (new IntegerNode(0-Integer.parseInt(v_Type.getTokenValue()))));
                    }
                    else
                        throw new SyntaxErrorException("Syntax exption: invalid constants");
                }
                if((v_Type = matchAndRemove(Token.tokenType.REAL)) != null)
                {
                    v_ReturnConts[v_level] = new VariableNode(v_Name.getTokenValue(), v_Type.getTokenType().toString().toLowerCase(), false, (new RealNode(Float.parseFloat(v_Type.getTokenValue()))));
                }
                if((v_Type = matchAndRemove(Token.tokenType.INTEGER)) != null)
                {
                    v_ReturnConts[v_level] = new VariableNode(v_Name.getTokenValue(), v_Type.getTokenType().toString().toLowerCase(), false, (new IntegerNode(Integer.parseInt(v_Type.getTokenValue()))));
                }
                if((v_Type = matchAndRemove(Token.tokenType.FALSE)) != null)
                {
                    v_ReturnConts[v_level] = new VariableNode(v_Name.getTokenValue(), v_Type.getTokenType().toString().toLowerCase(), false, (new BoolNode(false)));
                }
                if((v_Type = matchAndRemove(Token.tokenType.TRUE)) != null)
                {
                    v_ReturnConts[v_level] = new VariableNode(v_Name.getTokenValue(), v_Type.getTokenType().toString().toLowerCase(), false, (new BoolNode(true)));
                }
                if((v_Type = matchAndRemove(Token.tokenType.STRINGLITERAL)) != null)
                {
                    v_ReturnConts[v_level] = new VariableNode(v_Name.getTokenValue(), v_Type.getTokenType().toString().toLowerCase(), false, (new StringNode(v_Type.getTokenValue(), v_Name.getTokenValue())));
                }
                if((v_Type = matchAndRemove(Token.tokenType.CHARACTERLITERAL)) != null)
                {
                    v_ReturnConts[v_level] = new VariableNode(v_Name.getTokenValue(), v_Type.getTokenType().toString().toLowerCase(), false, (new CharNode(v_Type.getTokenValue().charAt(0), v_Name.getTokenValue())));
                }

                return v_ReturnConts;
            }
        }

        //if the next line is also conts
        throw new SyntaxErrorException("kill me");
        //return v_ReturnConts;
    }

    //parses variable list 
    public VariableNode[] variableParse() throws SyntaxErrorException
    {    
        Token v_Name, v_Type;
        int count = 1, distance = 1, index = 0; // num of vars 

        while(peek(distance).getTokenType() != Token.tokenType.TYPEDECLAR )
        {
            count++;
            distance+=2;
        }
        
        VariableNode[] v_ReturnVars = new VariableNode[count];

        while(count > 0)
        {
            if((v_Name = matchAndRemove(Token.tokenType.IDENTIFIER)) != null)
            {
                if(matchAndRemove(Token.tokenType.COMMA) != null)
                {
                    v_ReturnVars[index] = new VariableNode(v_Name.getTokenValue(), null, true);
                    index++;
                }
            }
            if(matchAndRemove(Token.tokenType.TYPEDECLAR) != null)
            {
                if((v_Type = matchAndRemove(Token.tokenType.INTEGER)) != null || (v_Type = matchAndRemove(Token.tokenType.REAL)) != null || (v_Type = matchAndRemove(Token.tokenType.BOOLEAN)) != null || (v_Type = matchAndRemove(Token.tokenType.STRING)) != null || (v_Type = matchAndRemove(Token.tokenType.CHARACTER)) != null)
                {
                    if(matchAndRemove(Token.tokenType.FROM) != null)
                    {
                        if(v_Type.getTokenType() == Token.tokenType.REAL)
                        {
                            Token powerRanger = matchAndRemove(Token.tokenType.REAL);
                            float lower = Float.parseFloat(powerRanger.getTokenValue()); 
                            matchAndRemove(Token.tokenType.TO);
                            powerRanger = matchAndRemove(Token.tokenType.REAL);
                            float upper = Float.parseFloat(powerRanger.getTokenValue());
                            v_ReturnVars[index] = new VariableNode(v_Name.getTokenValue(), v_Type.getTokenType().toString().toLowerCase(), true, lower, upper);
                        }
                        else
                        {
                            Token powerRanger = matchAndRemove(Token.tokenType.INTEGER);
                            int lower = Integer.parseInt(powerRanger.getTokenValue()); 
                            matchAndRemove(Token.tokenType.TO);
                            powerRanger = matchAndRemove(Token.tokenType.INTEGER);
                            int upper = Integer.parseInt(powerRanger.getTokenValue());
                            v_ReturnVars[index] = new VariableNode(v_Name.getTokenValue(), v_Type.getTokenType().toString().toLowerCase(), true, lower, upper); 
                        }                        
                    }
                    else
                        v_ReturnVars[index] = new VariableNode(v_Name.getTokenValue(), v_Type.getTokenType().toString().toLowerCase(), true);
                    for(int i = 0; i < v_ReturnVars.length; i++) // cuz we filled with null while reading in var names, then set all them to the type once we reach its token
                    {
                        v_ReturnVars[i].setType(v_Type.getTokenType().toString().toLowerCase());
                    }
                    return v_ReturnVars;
                }
            }
            count--;
        }

        return v_ReturnVars;
    }

    //check to see if ther are any variable declarations before right paren
    public VariableNode[] parameterDeclarations() throws SyntaxErrorException
    {
        Token v_Name, v_Type;
        int count = 0, distance = 0, types = 0; // num of params 

        while(peek(distance).getTokenType() != Token.tokenType.ENDPARAMS )
        {
            if(peek(distance).getTokenType() == Token.tokenType.IDENTIFIER)
                count++;
            if(peek(distance).getTokenType() == Token.tokenType.TYPEDECLAR)
                types++;
            distance++;
        }

        VariableNode[] v_ReturnParams = new VariableNode[count];
        boolean changable = false;
    
        while (types >= 0)
        {
            if(matchAndRemove(Token.tokenType.SEMICOLON) == null)
            {
                int index = 0;
                if(matchAndRemove(Token.tokenType.VAR) != null)
                {
                    changable = true;
                }
                while((v_Name = matchAndRemove(Token.tokenType.IDENTIFIER)) != null)
                {
                    if(matchAndRemove(Token.tokenType.COMMA) != null)
                    {
                        v_ReturnParams[index] = new VariableNode(v_Name.getTokenValue(), null, changable);
                        index++;
                    }
                    if(matchAndRemove(Token.tokenType.TYPEDECLAR) != null)
                    {
                        if((v_Type = matchAndRemove(Token.tokenType.INTEGER)) != null || (v_Type = matchAndRemove(Token.tokenType.REAL)) != null || (v_Type = matchAndRemove(Token.tokenType.BOOLEAN)) != null || (v_Type = matchAndRemove(Token.tokenType.STRING)) != null || (v_Type = matchAndRemove(Token.tokenType.CHARACTER)) != null)
                        {
                            v_ReturnParams[index] = new VariableNode(v_Name.getTokenValue(), v_Type.getTokenType().toString().toLowerCase(), changable);
                            for(int i = 0; i <= index; i++) 
                            {
                                v_ReturnParams[i].setType(v_Type.getTokenType().toString().toLowerCase());
                            }
                        }
                    }
                }
            }
            types--;
        }
        return v_ReturnParams;
    }

    //eats all end of lines when called if non exist it errors
    public void expectEndsOfLine () throws SyntaxErrorException 
    {
        int numberOfEndsEaten = 0;
        while (matchAndRemove(Token.tokenType.ENDOFLINE) != null) // eat all ENDOFLINE tokens
        {
            numberOfEndsEaten++;
        }
        if (numberOfEndsEaten <= 0) 
        {
            throw new SyntaxErrorException("Expected end of line" + m_Tokens);
        }
    }

    //match the types of the passed tokentype to the toketype of the next token in the list
    public Token matchAndRemove(Token.tokenType p_GivenTokenType)
    {
        if(m_Tokens.size() <= 0)
            return null;
        if(m_Tokens.get(0).getTokenType() == p_GivenTokenType)
        {
            Token returnToken = m_Tokens.get(0);
            m_Tokens.remove(0);
            return returnToken;
        }
        else
            return null;
    } 

    //parses an assigment when called if invalid, thros syntax error
    private AssignmentNode assignment() throws SyntaxErrorException 
    {
        AssignmentNode assigment;
   
        VariableReferenceNode target = variableReference();
        if (matchAndRemove(Token.tokenType.ASSIGMENT) == null) 
        {
            throw new SyntaxErrorException("Expected ':=' for a valid assignment.");
        }

        Node value = boolCompare();

        if(target == null && value == null)
        {
            return null;
        }
        
        assigment = new AssignmentNode(target, value);
        return assigment;
    }

    //parses a expected reference variable, errors if invalid
    private VariableReferenceNode variableReference() throws SyntaxErrorException 
    {
        Token v_Token = matchAndRemove(Token.tokenType.IDENTIFIER);
        if (v_Token == null) 
        {
            throw new SyntaxErrorException("Expected identifier in variable reference." + m_Tokens);
        }
        String  v_Name = v_Token.getTokenValue();

        Node indexExp = null; // the index
        if(matchAndRemove(Token.tokenType.STARTINDEX) != null)
        {
            indexExp = expression();
            if(((MathOpNode)indexExp).m_MathOpType == null)
            {
                indexExp = ((MathOpNode)indexExp).m_LeftNode;
            }
            if (indexExp == null) 
            {
                throw new SyntaxErrorException("Expected expression inside array index brackets.");
            }
            if (matchAndRemove(Token.tokenType.ENDINDEX) == null) 
            {
                throw new SyntaxErrorException("Expected ']' after array index expression.");
            }
        }
        if (indexExp == null) // i.e not an array
        {
            return new VariableReferenceNode(v_Name);
        } 
        else 
        {
            return new ArrayReferenceNode(v_Name, indexExp);
        }
    }

    //parses a for loop
    private ForNode parseFor() throws SyntaxErrorException
    {
        Token indexVariable = matchAndRemove(Token.tokenType.IDENTIFIER);

        if(matchAndRemove(Token.tokenType.FROM) == null)
            throw new SyntaxErrorException("invalid for loop syntax. Expected token 'from'");
        Node lowerRange = expression();
        if(matchAndRemove(Token.tokenType.TO) == null)
            throw new SyntaxErrorException("invalid for loop syntax. Expected token 'to'");
        Node upperRange = expression();
        expectEndsOfLine();

        return new ForNode(lowerRange, upperRange, statements(), indexVariable);
    }

    //parses an  if statement
    private IfNode parseIf() throws SyntaxErrorException
    {
        BooleanCompareNode comparision = (BooleanCompareNode)boolCompare();
        matchAndRemove(Token.tokenType.THEN);
        expectEndsOfLine();
        ArrayList<StatementNode> localStatements = statements();

        IfNode returnNode = new IfNode(comparision, localStatements, null);

        if(matchAndRemove(Token.tokenType.ELSIF) != null)
        {
            BooleanCompareNode localComparision = (BooleanCompareNode)boolCompare();
            matchAndRemove(Token.tokenType.THEN);
            expectEndsOfLine();
            returnNode.setElseIfNode(new IfNode(localComparision, statements(), null));
        }
        if(matchAndRemove(Token.tokenType.ELSE) != null)
        {
            expectEndsOfLine();
            returnNode.setElseIfNode(new IfNode(null, statements(), null));

        }
        return returnNode;
    }

    //parses a while loop
    private WhileNode parseWhile() throws SyntaxErrorException
    {
        BooleanCompareNode condition = (BooleanCompareNode)boolCompare();
        expectEndsOfLine();
        return new WhileNode(condition, statements());
    }

    //parses function calls
    private FunctionCallNode parseFunctionCalls() throws SyntaxErrorException
    {
        Token tempToken = matchAndRemove(Token.tokenType.IDENTIFIER);
        ArrayList<ParameterNode> funcParams = new ArrayList<ParameterNode>(); //parms for our function, filled up under
        if(v_RootOfAST.hasFunction(tempToken.getTokenValue())) //if the func is exists 
        {
            while(true)
            {
                ParameterNode currentParam = new ParameterNode(boolCompare());
                matchAndRemove(Token.tokenType.COMMA);
                funcParams.add(currentParam);
    
                if(matchAndRemove(Token.tokenType.ENDOFLINE) != null)
                {
                    break;
                }
            }
            return new FunctionCallNode(tempToken.getTokenValue(), funcParams);
        }
        else
            throw new SyntaxErrorException("Function referred without definition");
    }

    //returns ther next noken in the list if it exits
    public Token peek(int p_IndexAgument)
    {
        if (p_IndexAgument < m_Tokens.size())
            return m_Tokens.get(p_IndexAgument);
        else
            return null;
    }
    //follows the grammer of expression in shank
    private MathOpNode expression() throws SyntaxErrorException
    {
        Node v_LeftAccumulate = term();

        while(true)
        {
            if (matchAndRemove(Token.tokenType.PLUS) != null)
            {
                Node v_RightAccumulate = term();
                v_LeftAccumulate = new MathOpNode(v_LeftAccumulate, v_RightAccumulate, MathOpNode.mathops.PLUS);

            }
            else if (matchAndRemove(Token.tokenType.MINUS) != null)
            {
                Node v_RightAccumulate = term();
                v_LeftAccumulate = new MathOpNode(v_LeftAccumulate, v_RightAccumulate, MathOpNode.mathops.MINUS);
            }
            else
            {
                return (new MathOpNode(v_LeftAccumulate, v_LeftAccumulate, null));
            }
        }
    }
    //follows the grammer of term in shank
    private Node term() throws SyntaxErrorException
    {
        Node v_LeftAccumulate = factor();
        while(true)
        {
            if (matchAndRemove(Token.tokenType.MULTIPLY) != null)
            {
                Node v_RightAccumulate = factor();
                v_LeftAccumulate = new MathOpNode(v_LeftAccumulate, v_RightAccumulate, MathOpNode.mathops.MULTIPLY);
            }
            else if (matchAndRemove(Token.tokenType.INTDIVITION) != null)
            {
                Node v_RightAccumulate = factor();
                v_LeftAccumulate = new MathOpNode(v_LeftAccumulate, v_RightAccumulate, MathOpNode.mathops.INTDIVITION);
            }
            else if(matchAndRemove(Token.tokenType.MOD) != null)
            {
                Node v_RightAccumulate = factor();
                v_LeftAccumulate = new MathOpNode(v_LeftAccumulate, v_RightAccumulate, MathOpNode.mathops.MOD);
            }
            else
                return v_LeftAccumulate;
        }
    }
    //follows the grammer of factor in shank
    private Node factor() throws SyntaxErrorException 
    {
        Token currentToken;
        Node returnNode = null;

        if (matchAndRemove(Token.tokenType.MINUS) != null) 
        {
            if((currentToken = matchAndRemove(Token.tokenType.INTEGER)) != null)
            {
                returnNode = new IntegerNode(0-Integer.parseInt(currentToken.getTokenValue()));
            }
            else if ((currentToken = matchAndRemove(Token.tokenType.REAL)) != null)
            {
                matchAndRemove(Token.tokenType.REAL);
                returnNode = new RealNode(0-Float.parseFloat(currentToken.getTokenValue()));
            }
            else 
                throw new SyntaxErrorException();
        } 
        else if ((currentToken = matchAndRemove(Token.tokenType.INTEGER)) != null) 
        {
            matchAndRemove(Token.tokenType.INTEGER);
            returnNode = new IntegerNode(Integer.parseInt(currentToken.getTokenValue()));
        }
        else if ((currentToken = matchAndRemove(Token.tokenType.REAL)) != null) 
        {
            matchAndRemove(Token.tokenType.REAL);
            returnNode = new RealNode(Float.parseFloat(currentToken.getTokenValue()));
        }  
        
        else if (matchAndRemove(Token.tokenType.STARTPARAMS) != null) 
        {
            matchAndRemove(Token.tokenType.STARTPARAMS);
            returnNode = expression();
            matchAndRemove(Token.tokenType.ENDPARAMS);
        }
        else if ((currentToken = matchAndRemove(Token.tokenType.IDENTIFIER)) != null) // variabale name
        {
            String name = currentToken.getTokenValue();
            if (matchAndRemove(Token.tokenType.STARTINDEX) != null) //if array
            {
                Node index = expression();
                matchAndRemove(Token.tokenType.ENDINDEX);
                returnNode = new VariableReferenceNode(name, index);
            }
            else 
                returnNode = new VariableReferenceNode(name);
        }
        else if (matchAndRemove(Token.tokenType.TRUE) != null) 
        {
            returnNode = new BoolNode(true);
        }
        else if (matchAndRemove(Token.tokenType.FALSE) != null) 
        {
            returnNode = new BoolNode(false);
        }
        else 
            return returnNode;
        return returnNode;
    }

}
