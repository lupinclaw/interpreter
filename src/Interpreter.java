import java.util.ArrayList;
import java.util.HashMap;

//interprets an AST (generated by parser)
public class Interpreter 
{
    ProgramNode m_TheProgram;

    public Interpreter(ProgramNode p_Program) throws SyntaxErrorException
    {
        m_TheProgram = p_Program;
        
        interpretFunction(m_TheProgram.getFunction("start"));
    }


    public void interpretFunction(FunctionNode p_ASTFunction) throws SyntaxErrorException 
    {
        HashMap<String, InterpreterDataType> localVairables = new HashMap<>();
        
        if(p_ASTFunction.getVariables() != null)
        {
            for(Node index: p_ASTFunction.getVariables())
            {
                if(((VariableNode)index).getType().equals("integer"))
                {
                    localVairables.put(((VariableNode)index).getName(), new IntegerDataType());
                }
                if(((VariableNode)index).getType().equals("string"))
                {
                    localVairables.put(((VariableNode)index).getName(), new StringDataType());
                }
                if(((VariableNode)index).getType().equals("real"))
                {
                    localVairables.put(((VariableNode)index).getName(), new RealDataType());
                }
                if(((VariableNode)index).getType().equals("character"))
                {
                    localVairables.put(((VariableNode)index).getName(), new CharacterDataType());
                }
                if(((VariableNode)index).getType().equals("array") )
                {
                    localVairables.put(((VariableNode)index).getName(), new ArrayDataType(null));
                }
            }
        }
        if(p_ASTFunction.getConstants() != null)
        {
            for(Node index: p_ASTFunction.getConstants())
            {
                if(((VariableNode)index).getType().equals("integer") )
                {
                    localVairables.put(((VariableNode)index).getName(), new IntegerDataType(((IntegerNode)(((VariableNode)index).getValue())).getValue()));
                }
                if(((VariableNode)index).getType().equals("string"))
                {
                    localVairables.put(((VariableNode)index).getName(), new StringDataType(((StringNode)(((VariableNode)index).getValue())).getValue()));
                }
                if(((VariableNode)index).getType().equals("real"))
                {
                    localVairables.put(((VariableNode)index).getName(), new RealDataType(((RealNode)(((VariableNode)index).getValue())).getValue()));
                }
                if(((VariableNode)index).getType().equals("character"))
                {
                    localVairables.put(((VariableNode)index).getName(), new CharacterDataType(((CharNode)(((VariableNode)index).getValue())).getValue()));
                }
                if(((VariableNode)index).getType().equals("array") )
                {
                    localVairables.put(((VariableNode)index).getName(), new ArrayDataType(null));
                }
            }
        }
        if(p_ASTFunction.getParameters() != null)
        {
            for(Node index: p_ASTFunction.getParameters())
            {
                if(index == null) //idk y the for x in y loop is returning nulls but this was all i could do to hold back the tide of javas sufficating annoyingness
                    continue;

                if(((VariableNode)index).getType().equals("integer"))
                {
                    localVairables.put(((VariableNode)index).getName(), new IntegerDataType());
                }
                if(((VariableNode)index).getType().equals("string"))
                {
                    localVairables.put(((VariableNode)index).getName(), new StringDataType());
                }
                if(((VariableNode)index).getType().equals("real"))
                {
                    localVairables.put(((VariableNode)index).getName(), new RealDataType());
                }
                if(((VariableNode)index).getType().equals("character"))
                {
                    localVairables.put(((VariableNode)index).getName(), new CharacterDataType());
                }
                if(((VariableNode)index).getType().equals("array"))
                {
                    localVairables.put(((VariableNode)index).getName(), new ArrayDataType(null));
                }
            }
        }

        System.out.println("Map Before Interp: KEY: "+localVairables.keySet()+"\tVAL: " + localVairables.values());
        interpretBlock(localVairables, p_ASTFunction.getStatments());
        System.out.println("Map After Interp: KEY: "+localVairables.keySet()+"\tVAL: " + localVairables.values());
        //Finally, pass the hash map and the collection of StatementNode to interpretBlock(). 
    }

    //same thing as above but can be pasted a hashmap of IDTS instead of making a blank new one
    public void interpretFunction(FunctionNode p_ASTFunction, HashMap<String, InterpreterDataType> p_localVairables) throws SyntaxErrorException 
    {
        HashMap<String, InterpreterDataType> localVairables = p_localVairables;
        
        if(p_ASTFunction.getVariables() != null)
        {
            for(Node index: p_ASTFunction.getVariables())
            {
                if(((VariableNode)index).getType().equals("integer"))
                {
                    localVairables.put(((VariableNode)index).getName(), new IntegerDataType());
                }
                if(((VariableNode)index).getType().equals("string"))
                {
                    localVairables.put(((VariableNode)index).getName(), new StringDataType());
                }
                if(((VariableNode)index).getType().equals("real"))
                {
                    localVairables.put(((VariableNode)index).getName(), new RealDataType());
                }
                if(((VariableNode)index).getType().equals("character"))
                {
                    localVairables.put(((VariableNode)index).getName(), new CharacterDataType());
                }
                if(((VariableNode)index).getType().equals("array") )
                {
                    localVairables.put(((VariableNode)index).getName(), new ArrayDataType(null));
                }
            }
        }
        if(p_ASTFunction.getConstants() != null)
        {
            for(Node index: p_ASTFunction.getConstants())
            {
                if(((VariableNode)index).getType().equals("integer") )
                {
                    localVairables.put(((VariableNode)index).getName(), new IntegerDataType(((IntegerNode)(((VariableNode)index).getValue())).getValue()));
                }
                if(((VariableNode)index).getType().equals("string"))
                {
                    localVairables.put(((VariableNode)index).getName(), new StringDataType(((StringNode)(((VariableNode)index).getValue())).getValue()));
                }
                if(((VariableNode)index).getType().equals("real"))
                {
                    localVairables.put(((VariableNode)index).getName(), new RealDataType(((RealNode)(((VariableNode)index).getValue())).getValue()));
                }
                if(((VariableNode)index).getType().equals("character"))
                {
                    localVairables.put(((VariableNode)index).getName(), new CharacterDataType(((CharNode)(((VariableNode)index).getValue())).getValue()));
                }
                if(((VariableNode)index).getType().equals("array") )
                {
                    localVairables.put(((VariableNode)index).getName(), new ArrayDataType(null));
                }
            }
        }
        if(p_ASTFunction.getParameters() != null)
        {
            for(Node index: p_ASTFunction.getParameters())
            {
                if(index == null) //idk y the for x in y loop is returning nulls but this was all i could do to hold back the tide of javas sufficating annoyingness
                    continue;

                if(((VariableNode)index).getType().equals("integer"))
                {
                    localVairables.put(((VariableNode)index).getName(), new IntegerDataType());
                }
                if(((VariableNode)index).getType().equals("string"))
                {
                    localVairables.put(((VariableNode)index).getName(), new StringDataType());
                }
                if(((VariableNode)index).getType().equals("real"))
                {
                    localVairables.put(((VariableNode)index).getName(), new RealDataType());
                }
                if(((VariableNode)index).getType().equals("character"))
                {
                    localVairables.put(((VariableNode)index).getName(), new CharacterDataType());
                }
                if(((VariableNode)index).getType().equals("array"))
                {
                    localVairables.put(((VariableNode)index).getName(), new ArrayDataType(null));
                }
            }
        }

        System.out.println("Map Before Interp: KEY: "+localVairables.keySet()+"\tVAL: " + localVairables.values());
        interpretBlock(localVairables, p_ASTFunction.getStatments());
        System.out.println("Map After Interp: KEY: "+localVairables.keySet()+"\tVAL: " + localVairables.values());
        //Finally, pass the hash map and the collection of StatementNode to interpretBlock(). 
    }

    public void interpretBlock(HashMap<String, InterpreterDataType> p_localVairable, ArrayList<StatementNode> p_StatementNodes) throws SyntaxErrorException
    {
        for(Node index : p_StatementNodes)
        {
            if(index instanceof VariableReferenceNode)
            {
                variableReferenceNode(p_localVairable,(VariableReferenceNode)index);
            }
            if(index instanceof MathOpNode)
            {
                mathOpNode(p_localVairable,(MathOpNode)index);
            }
            if(index instanceof AssignmentNode)
            {
                assignmentNode(p_localVairable,(AssignmentNode)index);
            }
            if(index instanceof WhileNode)
            {
                whileNode(p_localVairable,(WhileNode)index);
            }
            if(index instanceof IfNode)
            {
                ifNode(p_localVairable, (IfNode)index);
            }
            if(index instanceof ForNode)
            {
                forNode(p_localVairable,(ForNode)index);
            }
            if(index instanceof RepeatNode)
            {
                repeatNode(p_localVairable,(RepeatNode)index);
            }
        }
    }

    public InterpreterDataType expression(HashMap<String, InterpreterDataType> p_localVairable, Node p_Node) throws SyntaxErrorException
    {

        if(p_Node instanceof VariableReferenceNode)
        {
            if(p_localVairable.containsKey(((VariableReferenceNode)p_Node).getName()) == true)
            {
                return p_localVairable.get(((VariableReferenceNode)p_Node).getName());
            }
            else
                throw new SyntaxErrorException("Error: Reference variable that does not exist in scope");
        }
        if(p_Node instanceof IntegerNode)
        {
            return new IntegerDataType(((IntegerNode)p_Node).getValue());
        }
        if(p_Node instanceof RealNode)
        {
            return new RealDataType(((RealNode)p_Node).getValue());
        }
        if(p_Node instanceof StringNode)
        {
            return new StringDataType(((StringNode)p_Node).getValue());
        }
        if(p_Node instanceof CharNode)
        {
            return new StringDataType(Character.toString(((CharNode)p_Node).getValue()));
        }
        if(p_Node instanceof MathOpNode)
        {
            return mathOpNode(p_localVairable, (MathOpNode)p_Node);
        }

        throw new SyntaxErrorException("Error: expression bottomed out");
    }

    public BooleanDataType booleanCompare(HashMap<String, InterpreterDataType> p_localVairable, BooleanCompareNode p_Node) throws SyntaxErrorException
    {
        InterpreterDataType leftSide = expression(p_localVairable,p_Node.getLeft());
        InterpreterDataType rightSide = expression(p_localVairable,p_Node.getRight());

        if(leftSide instanceof IntegerDataType)
        {
            if(rightSide instanceof IntegerDataType)
            {
                if(p_Node.getOperator() == BooleanCompareNode.boolOperation.EQUAL)
                {
                    return new BooleanDataType(((IntegerDataType)leftSide).getValue() == ((IntegerDataType)rightSide).getValue());
                }
                if(p_Node.getOperator() == BooleanCompareNode.boolOperation.NOTEQUAL)
                {
                    return new BooleanDataType(((IntegerDataType)leftSide).getValue() != ((IntegerDataType)rightSide).getValue());
                }
                if(p_Node.getOperator() == BooleanCompareNode.boolOperation.LESSTHAN)
                {
                    return new BooleanDataType(((IntegerDataType)leftSide).getValue() < ((IntegerDataType)rightSide).getValue());
                }
                if(p_Node.getOperator() == BooleanCompareNode.boolOperation.GREATERTHAN)
                {
                    return new BooleanDataType(((IntegerDataType)leftSide).getValue() > ((IntegerDataType)rightSide).getValue());
                }
                if(p_Node.getOperator() == BooleanCompareNode.boolOperation.LESSTHANEQUAL)
                {
                    return new BooleanDataType(((IntegerDataType)leftSide).getValue() <= ((IntegerDataType)rightSide).getValue());
                }
                if(p_Node.getOperator() == BooleanCompareNode.boolOperation.GREATERTHANEQUAL)
                {
                    return new BooleanDataType(((IntegerDataType)leftSide).getValue() >= ((IntegerDataType)rightSide).getValue());
                }
            }
            else
                throw new SyntaxErrorException("Error: boolcompare on diff types of ndoes");
        }
        if(leftSide instanceof RealDataType)
        {
            if(rightSide instanceof RealDataType)
            {
                if(p_Node.getOperator() == BooleanCompareNode.boolOperation.EQUAL)
                {
                    return new BooleanDataType(((RealDataType)leftSide).getValue() == ((RealDataType)rightSide).getValue());
                }
                if(p_Node.getOperator() == BooleanCompareNode.boolOperation.NOTEQUAL)
                {
                    return new BooleanDataType(((RealDataType)leftSide).getValue() != ((RealDataType)rightSide).getValue());
                }
                if(p_Node.getOperator() == BooleanCompareNode.boolOperation.LESSTHAN)
                {
                    return new BooleanDataType(((RealDataType)leftSide).getValue() < ((RealDataType)rightSide).getValue());
                }
                if(p_Node.getOperator() == BooleanCompareNode.boolOperation.GREATERTHAN)
                {
                    return new BooleanDataType(((RealDataType)leftSide).getValue() > ((RealDataType)rightSide).getValue());
                }
                if(p_Node.getOperator() == BooleanCompareNode.boolOperation.LESSTHANEQUAL)
                {
                    return new BooleanDataType(((RealDataType)leftSide).getValue() <= ((RealDataType)rightSide).getValue());
                }
                if(p_Node.getOperator() == BooleanCompareNode.boolOperation.GREATERTHANEQUAL)
                {
                    return new BooleanDataType(((RealDataType)leftSide).getValue() >= ((RealDataType)rightSide).getValue());
                }
            }
            else
                throw new SyntaxErrorException("Error: boolcompare on diff types of ndoes");
        }
        if(leftSide instanceof StringDataType)
        {
            if(rightSide instanceof StringDataType)
            {
                if(p_Node.getOperator() == BooleanCompareNode.boolOperation.EQUAL)
                {
                    return new BooleanDataType(((StringDataType)leftSide).getValue() == ((StringDataType)rightSide).getValue());
                }
                if(p_Node.getOperator() == BooleanCompareNode.boolOperation.NOTEQUAL)
                {
                    return new BooleanDataType(((StringDataType)leftSide).getValue() != ((StringDataType)rightSide).getValue());
                }
            }
            else
                throw new SyntaxErrorException("Error: boolcompare on diff types of ndoes");
        }
        throw new SyntaxErrorException("Error: boolcompare bottomed out");
    }

    public InterpreterDataType variableReferenceNode(HashMap<String, InterpreterDataType> p_localVairable, VariableReferenceNode p_Node) throws SyntaxErrorException
    {
        if(p_localVairable.containsKey(p_Node.getName()) == true)
        {
            return p_localVairable.get(p_Node.getName());
        }
        else
            throw new SyntaxErrorException("Error: Reference variable that does not exist in scope");
    }

    public InterpreterDataType mathOpNode(HashMap<String, InterpreterDataType> p_localVairable,MathOpNode p_Node) throws SyntaxErrorException
    {
        InterpreterDataType leftSide = expression(p_localVairable,p_Node.m_LeftNode);
        InterpreterDataType rightSide = expression(p_localVairable,p_Node.m_RightNode);

        if(leftSide instanceof IntegerDataType)
        {
            if(rightSide instanceof IntegerDataType)
            {
                if(p_Node.m_MathOpType == MathOpNode.mathops.PLUS)
                {
                    return new IntegerDataType(((IntegerDataType)leftSide).getValue() + ((IntegerDataType)rightSide).getValue());
                }
                if(p_Node.m_MathOpType == MathOpNode.mathops.MINUS)
                {
                    return new IntegerDataType(((IntegerDataType)leftSide).getValue() - ((IntegerDataType)rightSide).getValue());
                }
                if(p_Node.m_MathOpType == MathOpNode.mathops.MULTIPLY)
                {
                    return new IntegerDataType(((IntegerDataType)leftSide).getValue() * ((IntegerDataType)rightSide).getValue());
                }
                if(p_Node.m_MathOpType == MathOpNode.mathops.INTDIVITION)
                {
                    return new IntegerDataType(((IntegerDataType)leftSide).getValue() / ((IntegerDataType)rightSide).getValue());
                }
                if(p_Node.m_MathOpType == MathOpNode.mathops.MOD)
                {
                    return new IntegerDataType(((IntegerDataType)leftSide).getValue() % ((IntegerDataType)rightSide).getValue());
                }
                if(p_Node.m_MathOpType == null)
                {
                    return new IntegerDataType(((IntegerDataType)leftSide).getValue()); //null is a mathop node thats just a const or vari
                }
            }
            else
                throw new SyntaxErrorException("Error: math op on diff types of ndoes");
        }
        if(leftSide instanceof RealDataType)
        {
            if(rightSide instanceof RealDataType)
            {
                if(p_Node.m_MathOpType == MathOpNode.mathops.PLUS)
                {
                    return new RealDataType(((RealDataType)leftSide).getValue() + ((RealDataType)rightSide).getValue());
                }
                if(p_Node.m_MathOpType == MathOpNode.mathops.MINUS)
                {
                    return new RealDataType(((RealDataType)leftSide).getValue() - ((RealDataType)rightSide).getValue());
                }
                if(p_Node.m_MathOpType == MathOpNode.mathops.MULTIPLY)
                {
                    return new RealDataType(((RealDataType)leftSide).getValue() * ((RealDataType)rightSide).getValue());
                }
                if(p_Node.m_MathOpType == MathOpNode.mathops.INTDIVITION)
                {
                    return new RealDataType(((RealDataType)leftSide).getValue() / ((RealDataType)rightSide).getValue());
                }
                if(p_Node.m_MathOpType == MathOpNode.mathops.MOD)
                {
                    return new RealDataType(((RealDataType)leftSide).getValue() % ((RealDataType)rightSide).getValue());
                }
                if(p_Node.m_MathOpType == null)
                {
                    return new RealDataType(((RealDataType)leftSide).getValue());
                }
            }
            else
                throw new SyntaxErrorException("Error: math op on diff types of ndoes");
        }
        if(leftSide instanceof StringDataType)
        {
            if(rightSide instanceof StringDataType)
            {
                return new StringDataType(leftSide.ToString() + rightSide.toString());
            }
            else
                throw new SyntaxErrorException("Error: math op on diff types of ndoes");
        }
        throw new SyntaxErrorException("Error: math op bottomed out");
    }

    public void functionCallNode(HashMap<String, InterpreterDataType> p_localVairable,FunctionCallNode p_Node) throws SyntaxErrorException
    {
        FunctionNode func = m_TheProgram.getFunction(p_Node.getName());
        ArrayList<InterpreterDataType> paramsAsIDTs = new ArrayList<>();
        HashMap<String, InterpreterDataType> paramsAsIDTsWithNames = new HashMap<>();

        if(p_localVairable.containsKey(p_Node.getName()) == true)
        {
            if(!(func.isVariadic()))
            {
                //check params
                if(!(p_Node.getParams().size() == func.getParameters().length))
                    throw new SyntaxErrorException("Error: number of params do not match");
            }
            //params of function
            for(ParameterNode index : p_Node.getParams())
            {   
                InterpreterDataType tempIDT = expression(p_localVairable, index);
                paramsAsIDTs.add(tempIDT);
            }
            Node[] params = func.getParameters();
            for(int i = 0; i < paramsAsIDTs.size(); i++)
            {
                VariableNode index = (VariableNode)params[i];
                paramsAsIDTsWithNames.put(index.getName() , paramsAsIDTs.get(i));
            }

            if(func instanceof Read)//bult in
            {
                ((Read)func).execute(paramsAsIDTs);
            }
            else if(func instanceof Write)
            {
                ((Write)func).execute(paramsAsIDTs);
            }
            else if(func instanceof Substring)
            {
                ((Substring)func).execute(paramsAsIDTs);
            }
            else if(func instanceof Left)
            {
                ((Left)func).execute(paramsAsIDTs);
            }
            else if(func instanceof RealToInteger)
            {
                ((RealToInteger)func).execute(paramsAsIDTs);
            }
            else if(func instanceof GetRandom)
            {
                ((GetRandom)func).execute(paramsAsIDTs);
            }
            else if(func instanceof Start)
            {
                ((Start)func).execute(paramsAsIDTs);
            }
            else if(func instanceof SquareRoot)
            {
                ((SquareRoot)func).execute(paramsAsIDTs);
            }
            else if(func instanceof Right)
            {
                ((Right)func).execute(paramsAsIDTs);
            }
            else if(func instanceof End)
            {
                ((End)func).execute(paramsAsIDTs);
            }
            else //user defined
            {
                interpretFunction(func, paramsAsIDTsWithNames);
            }
        }
        else
        {
            throw new SyntaxErrorException("Error: tried to call function: " + p_Node.getName() + ", but does not exist");
        }
        int p_nodeParamindex = 0; //updates values of var variables after function is ran 
        ArrayList<ParameterNode> functionCallParams = p_Node.getParams();
        for(Node index: func.getParameters())
        {
            if(((VariableNode)index).getChangable()) //if is var
            {
                p_localVairable.put(((functionCallParams.get(p_nodeParamindex)).getVariableRef()).getName(), paramsAsIDTsWithNames.get(((VariableNode)index).getName()));
            }
            p_nodeParamindex++;
        }
    }


    public void ifNode(HashMap<String, InterpreterDataType> p_localVairable, IfNode p_Node) throws SyntaxErrorException
    {
        if(booleanCompare(p_localVairable, p_Node.getCondition()).getValue())
            interpretBlock(p_localVairable, p_Node.getStatements());
        else if(p_Node.getElseIfNode() != null)
            ifNode(p_localVairable, p_Node.getElseIfNode());
    }

    public void forNode(HashMap<String, InterpreterDataType> p_localVairable,ForNode p_Node) throws SyntaxErrorException
    {
        InterpreterDataType from = expression(p_localVairable, p_Node.getFrom());
        InterpreterDataType to = expression(p_localVairable, p_Node.getTo());
        int start = ((IntegerDataType)from).getValue();
        int end = ((IntegerDataType)to).getValue();

        if(p_localVairable.containsKey(p_Node.getIndexer())) //if the indexing variable for the loop is already used in scope error
        {
            throw new SyntaxErrorException("Variable already exits in scope");
        }
    
        for(int i = start; i <= end; i++)
        {
            p_localVairable.put(p_Node.getIndexer(), new IntegerDataType(i));
            interpretBlock(p_localVairable, p_Node.getStatements());
        }

        p_localVairable.remove(p_Node.getIndexer()); //remove outside of loop cuz its outstide of scope
    
    }

    public void repeatNode(HashMap<String, InterpreterDataType> p_localVairable,RepeatNode p_Node) throws SyntaxErrorException
    {
        do
        {
            interpretBlock(p_localVairable, p_Node.getStatements());
        }
        while(booleanCompare(p_localVairable, p_Node.getCondition()).getValue());
    }
    
    public void constantNodes() 
    {
        //idk if this was supposed to be in the rubric, but i handled my constants as variable reference nodes that r handled above
    }

    public void whileNode(HashMap<String, InterpreterDataType> p_localVairable,WhileNode p_Node) throws SyntaxErrorException
    {
        while(booleanCompare(p_localVairable, p_Node.getCondition()).getValue())
            interpretBlock(p_localVairable, p_Node.getStatements());
    }

    public void assignmentNode(HashMap<String, InterpreterDataType> p_localVairable,AssignmentNode p_Node) throws SyntaxErrorException
    {
        if(p_localVairable.containsKey(p_Node.getTarget().getName()) == true)
        {
            InterpreterDataType value = expression(p_localVairable, p_Node.getValue());
            p_localVairable.put(p_Node.getTarget().getName(), value);
        }
        else
            throw new SyntaxErrorException("Error: Reference variable that does not exist in scope ");
    }
   
}
